# README — FastAPI integration (`main.py`)

This README describes how to use the `main.py` example which demonstrates integrating the `gurutvapay_sdk.py` client into a FastAPI application. It includes configuration, endpoints, examples, and deployment tips.

---

## Overview

`main.py` is a minimal FastAPI app that wires the `GuruTvapayClient` SDK into your application and exposes simple HTTP endpoints merchants or internal services can call:

* `POST /create-payment` — create an order (calls `/initiate-payment` on GuruTvapay)
* `POST /transaction-status/{merchant_order_id}` — fetch transaction status
* `GET /transactions` — list transactions (paginated)
* `POST /webhook` — receive and verify gateway webhooks using HMAC-SHA256
* `GET /health` — simple health check

It demonstrates:

* Initializing the SDK on startup and storing it in `app.state`.
* Using FastAPI `Depends` to inject the client into handlers.
* Creating payments with optional idempotency headers.
* Verifying webhook signatures with the SDK helper `verify_webhook`.

---

## Requirements

* Python 3.8+
* `fastapi`, `uvicorn`, and `requests`

Install dependencies:

```bash
pip install fastapi uvicorn requests
```

---

## Environment Variables

Set these environment variables in your hosting environment (or a `.env` file when developing locally):

* `GURUTVA_ENV` — `'uat'` or `'live'` (default: `uat`)
* `GURUTVA_API_KEY` — API key for server-to-server requests (preferred) (optional if using OAuth)
* `GURUTVA_CLIENT_ID` — OAuth client id (if using password grant)
* `GURUTVA_CLIENT_SECRET` — OAuth client secret (if using password grant)
* `GURUTVA_USERNAME` — OAuth username (for password grant; optional)
* `GURUTVA_PASSWORD` — OAuth password (for password grant; optional)
* `GURUTVA_WEBHOOK_SECRET` — secret used to verify webhook signatures

Keep secrets out of source control and use a secrets manager in production.

---

## Endpoints & Examples

### 1) Create payment

**Route:** `POST /create-payment`
**Body (JSON):**

```json
{
  "amount":100,
  "merchant_order_id":"ORD123456",
  "channel":"web",
  "purpose":"Online Payment",
  "customer":{"buyer_name":"John","email":"a@b.com","phone":"9876543210"}
}
```

**Example `curl`:**

```bash
curl -X POST "http://localhost:8000/create-payment" \
  -H "Content-Type: application/json" \
  -d '{"amount":100,"merchant_order_id":"ORD123456","channel":"web","purpose":"Online Payment","customer":{"buyer_name":"John","email":"a@b.com","phone":"9876543210"}}'
```

> The handler demonstrates how to add an `Idempotency-Key` header automatically. If you need custom headers, the SDK exposes `client.request(...)` so you can pass headers, JSON body, etc.

### 2) Transaction status

**Route:** `POST /transaction-status/{merchant_order_id}`
This forwards to the gateway's `/<env>/transaction-status` endpoint using form-encoded body as shown in the API docs.

**Example `curl`:**

```bash
curl -X POST "http://localhost:8000/transaction-status/ORDER_2024_001"
```

### 3) Transaction list

**Route:** `GET /transactions?limit=50&page=0`
Returns the paginated list from the gateway.

**Example `curl`:**

```bash
curl -X GET "http://localhost:8000/transactions?limit=50&page=0"
```

### 4) Webhook (HMAC verification)

**Route:** `POST /webhook` — receives raw bytes and verifies the signature header. The code checks either `X-Signature` or `X-Gurutvapay-Signature` (adjust to your gateway headers).

**Signature format expected by the example:** `sha256=<hex>` where `<hex>` is the HMAC-SHA256 of the request body using `GURUTVA_WEBHOOK_SECRET`.

**Simulate webhook with `openssl` (bash):**

```bash
payload='{"merchantOrderId":"ORD123456","status":"success"}'
secret='secret123'
sig='sha256='$(echo -n $payload | openssl dgst -sha256 -hmac "$secret" -hex | sed 's/^.* //')

curl -X POST "http://localhost:8000/webhook" \
  -H "Content-Type: application/json" \
  -H "X-Signature: $sig" \
  -d "$payload"
```

If the signature verifies, the endpoint returns `200 OK` and you can process the event (update DB, fulfil order, notify user, etc.).

---

## Running locally

Start the app with uvicorn:

```bash
uvicorn main:app --reload --port 8000
```

Open `http://localhost:8000/docs` for interactive OpenAPI docs auto-generated by FastAPI.

---

## Production & Deployment Tips

* Use a process manager or ASGI server (e.g., Uvicorn/Uvicorn Workers under Gunicorn) for production.
* Serve behind a reverse proxy (NGINX) and terminate TLS there.
* Store secrets in environment variables or a secret store (AWS Secrets Manager, HashiCorp Vault, etc.).
* Configure logging and monitoring; capture errors from SDK calls and surface them in your app metrics.

---

## Async considerations

The provided SDK uses synchronous `requests`. For highly concurrent endpoints or non-blocking I/O in FastAPI, either:

1. Keep sync handlers but run blocking SDK calls in a threadpool via `run_in_threadpool` or `BackgroundTasks`, or
2. Use an `aiohttp`-based async SDK variant (I can create this for you).

Example using `BackgroundTasks` for post-webhook processing:

```py
from fastapi import BackgroundTasks

@app.post('/webhook')
async def webhook(request: Request, background_tasks: BackgroundTasks):
    raw = await request.body()
    # verify signature
    background_tasks.add_task(process_event, raw)
    return {"ok": True}
```

---

## Error handling

The SDK raises typed exceptions (`AuthError`, `NotFoundError`, `RateLimitError`, `GuruTvapayError`). Map these to appropriate HTTP responses as shown in the example (`401` for auth errors, `500` for generic failures).

---

## Security

* Never log full request bodies containing sensitive payment info.
* Rotate API keys and client secrets periodically.
* Validate and sanitize any incoming webhook payload before acting on it.

---

## Next steps I can help with

* Convert the SDK to an async `aiohttp` version and update `main.py` to async handlers.
* Add Dockerfile + Helm chart for deployment.
* Add unit tests for endpoints and CI (GitHub Actions) pipeline.

Tell me which one you want next.
